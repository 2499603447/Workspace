# 进程间通信

## 进程的种类

我们的系统中存在着多个进程，不同进程之间需要相互通信，因此进程间通信的方式应运而生。

在操作系统中，存在着多个同时运行的进程；这些进程可以是*独立进程(Independent processes)*或者*协作进程(Cooperating processes)* 。

*独立进程* - 不能影响（被）系统中正在运行的其他进程（影响）。

*协作进程* - 能影响（被）系统中正在运行的其他进程（影响）

任何和其他进程共享数据的进程都属于协作进程。

## 为什么需要进程间通信

* 信息共享

  一些用户都对同一块信息感兴趣，因此需要提供一种环境让多个用户都能够同时访问这块信息

* 加速计算

  我们有一个任务，需要将其分成一些子任务，这些子任务同时执行，从而可以加快我们任务的完成速度。

  现在这些子任务都有着一个相同的目标，但是却属于不同的进程，那么我们就需要提供一个环境让这些子任务之间能够互相通信，从而向着最终的目标前进

* 模块化

  在设计系统或者软件架构时，我们往往会将一个很大的功能拆解成不同的模块去实现，这些模块组合在一起从而实现一个共同的目标。那么这些模块之间必不可少地会存在互相通信的情况

* 便捷

  用户同一时刻可能会做很多事，比如听音乐、编辑文档或者打印文档。此时会涉及到多个不同的进程同时运行，那么进程之间的通信可以让使得多个进程流畅无冲突地运行，极大地提高了用户体验

因此需要一个进程间通信（*IPC*）机制使得在不同进程之间能够交互数据和信息。

有两个最基本的进程间通信模型：

| 名称                                    | 描述                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| <a href="#shared_memory">共享内存</a>   | 在共享内存模型中，会建立一块协作进程共享的内存区域。进程可以通过向共享的内存区域中读写数据从而达到交换数据的目的 |
| <a href="#message_passing">消息传递</a> | 在消息传递模型中，通过在不同进程间交换消息的方式实现进程间通信。 |

下图展示了共享内存和消息传递模型实现进程间通信的基本结构。

![共享内存&消息传递](../assets/1-76.png )

其他进程间通信方式：

| 名称 | 描述 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

## <a name="shared_memory">共享内存</a>

使用共享内存的进程间通信需要进程共享一些变量，这完全取决于编程人员如何实现它。一种使用的共享内存的通信方式可以这样：假设进程1和进程2正在同时执行，并且它们共享一些资源或使用来自另一个进程的一些信息。进程1生成有关正在使用的某些计算或资源的信息，并将其作为记录保存在共享内存中。当进程2需要使用共享信息时，它会检查共享内存中存储的记录，同时它会关注进程1生成的信息，并根据这些信息作出相应的动作。

进程可以使用共享内存从另外一个进程中提取信息作为记录，以及将任何特定信息传递给其他进程。

下面让我们来讨论使用共享内存实现进程间通信的示例。

> 在开始之前，我们先了解一下*生产者-消费者*问题
>
> 假设有两个进程：生产者和消费者。生产者生产一些物品，消费者消费该物品。这两个进程共享一个称为缓冲区的公共空间或内存位置；生产者生产的物品存储在其中，消费者在需要时从中消费物品。
>
> 生产者消费者存在两个问题：
>
> * 无界缓冲区问题
>
>   生产者可以一直生产物品，缓冲区的大小没有限制
>
> * 有界缓冲区问题
>
>   生产者可以生产到一定数量的物品，达到这个数量上限后，生产者必须等待消费者消费物品之后才能再次生产

我们来讨论有界缓冲区问题。首先，生产者和消费者将共享一些共同的内存区域，然后生产者将开始生产物品。同样，消费者将先检查物品的可用性。如果没有可用的物品，消费者将等待生产者生产它。如果有可用的物品，消费者将消费它们。

下面提供了用于演示的伪代码

* 两个进程共享的数据

  ```c
  #define buff_max 25
  #define mod %
   
  struct item{
      // different member of the produced data
      // or consumed data   
      ---------
  }
  
  // An array is needed for holding the items.
  // This is the shared place which will be 
  // access by both process  
  // item shared_buff [ buff_max ];
  
  // Two variables which will keep track of
  // the indexes of the items produced by producer
  // and consumer The free index points to
  // the next free index. The full index points to
  // the first full index.
  int free_index = 0;
  int full_index = 0;
  ```

* 生产者代码

  ```c
  item nextProduced;
       
  while (1) {
      // check if there is no space
      // for production.
      // if so keep waiting.
      while ((free_index + 1) mod buff_max == full_index);
      shared_buff[free_index] = nextProduced;
      free_index = (free_index + 1) mod buff_max;
  }
  ```

* 消费者代码

  ```c
  item nextConsumed;
       
  while (1) {
      // check if there is an available
      // item  for consumption.
      // if not keep on waiting for
      // get them produced.
      while (free_index == full_index);
      nextConsumed = shared_buff[full_index];
      full_index = (full_index + 1) mod buff_max;
  }
  ```

在上面的代码中，当(free_index + 1) mod buff_max和full_index相等时，表明此时缓存区中的item是满的，此时生产者需要等待消费者消费item，使得缓冲区不为空时，才能再次生产；同样的，当free_index和full_index相等时，表明此时缓冲区是空的，没有可供消费者消费的item，消费者需要等待生产者生产相应的item时，才能够继续消费。

## <a name="message_passing">消息传递</a>

现在我们开始讨论进程间通信的另外一种方式：消息传递。这种方式中，进程间的相互同行不再需要使用任何的共享内存。如果两个进程p1和p2想彼此间能够互相通信，它们可以这样处理：

![img](../assets/2-50.png)

* 建立一个通信链接（communication link）（如果链接已存在，则无需再次建立）

* 开始通过基本原语交换数据

  我们需要至少两个基本原语：

  -- send(message, destination)或者send(message)

  -- receive(message, host)或者receive(message)

消息大小可以是固定的大小或者变化的大小。如果是固定的大小，对OS设计者来说非常简单，但是对编程人员来说将会很复杂；如果是一个变化的大小，对于编程人员来说很容易，但是对OS设计者将会变得复杂。一个标准的消息可以有两个部分：**header和body**。

**Header**部分用于存储消息类型、消息的目的id、源id、消息长度和控制信息。控制信息包含：超过了缓冲区空间大小该如何做，序列号以及优先级。通常来说，消息使用FIFO方式进行发送。

### 通过通信链接实现消息传递

#### 直接和间接通信链接

现在，我们开始讨论通信链接的实现方式。在实现通信链接的同时，会存在一些问题，我们需要时刻牢记在脑海中：

1. 通信链接是如何建立的？
2. 一个通信链接可以和超过两个进程进行关联么？
3. 在每对通信的进程中，需要存在多少通信链接？
4. 通信链接的容量是多大？通信链接上所能容纳的消息大小是固定的还是可变的？
5. 通信链接是单向的还是双向的？

一个通信链接会有一定的容量，它决定了可以临时停留在其中的消息数量；每个通信链接都有一个与之关联的队列，该对列可以是零容量、有界容量或无界容量。在零容量情况下，发送方会等待，指导接收方通知发送方它已经收到消息。在非零容量情况下，进程不知道在发送操作之后对方是否已收到消息。为此，发送方必须明确地与接收方通信。链路的实现视情况而定，它可以是直接通信链路，也可以是间接通信链路。

通信链路的实现视情况而定，即可以是直接通信链接，也可以是间接通信链接。

**直接通信链接**：当进程使用特定的进程描述符，可以使用直接通信链接，但是很难提前识别发送者。

例如打印服务。

**间接通信链接**：通过共享邮箱（端口）的方式实现的，该邮箱由消息队列组成。发送者将消息放在邮箱中，接收者将消息从中取走。

### 通过交换消息实现消息传递

#### 同步和异步消息传递

被阻塞的进程是一个在等待某个事件的进程，例如资源变得可用或I/O操作的完成。IPC可以在同一台计算机上的不同进程之间进行，亦可以在那些运行在不同计算机上的进程之间进行，如在网络/分布式系统中。在这两种情况下，进程在发送消息或尝试接收消息时可能会或者可能不会阻塞，因此消息传递可能是阻塞的或者非阻塞的。阻塞被认为是**同步**的，**阻塞发送**意味着发送方将被阻塞，指导接收方收到消息。类似地，**阻塞接收**使接收方阻塞，直到消息可用。非阻塞被认为是**异步**的。非阻塞发送让发送者发完消息后能够继续后面的工作。类似地，非阻塞接收让接收方接收一个有效消息或者空消息。经过仔细分析，我们可以得出一个结论：对于发送方来说，消息传递后非阻塞更加自然合理，因为可能需要将消息发送到不同的进程。但是，如果消息发送失败，发送方希望收到接收方的确认。类似地，接收方处在接收阻塞更加自然，因为接收到的消息可用于进一步执行。同时，如果消息发送不断失败，接收者将不得不无限地等待。这就是为什么我们还要考虑消息传递的另一种可能性。基本上有三种优选组合：

* 阻塞发送和阻塞接收
* 非阻塞发送和非阻塞接收
* 非阻塞发送和阻塞接收（大多数使用这种）

**直接消息传递：**想要通信的进程必须明确命名通信的接收者或者发送者。

例如**send(p1, message)**表示将message发送到p1进程。同理，**receive(p2, message)**表示从p2进程接收message。

在这种通信方式中，通信链路是自动建立的，可以是单向的，也可以是双向的；但是一对发送方和接收方之间不能使用拥有超过一个链路。对称和非对称方式也可用于实现消息传递，即两个进程将相互命名以发送和接收消息，或者只有发送方命名接收方以用来发送消息，而无需接收方命名发送方。这种通信方式的问题在于，如果一个进程的名称发生变化，这种方法将不起作用。

**间接消息传递：**进程使用邮箱（端口）来发送和接收消息。每一个邮箱都有一个唯一的id，进程只有在共享邮箱时才能进行通信。仅当进程之间共享一个邮箱且单个链接可以与多个进程相关联时才建立链接。每对进程可以共享多个通信链接，这些链接可以是单向的或者双向的。假设两个进程之间通过间接消息传递，需要的操作是：创建一个邮箱，使用这个邮箱发送和接收消息，然后销毁这个邮箱。使用的标准原语是：**send(A, message)**这意味着将消息发送给邮箱A。接收消息的原语也以相同的方式工作，例如**received(A, message)**。这种实现方式有一个问题，假设两个以上的进程共享同一个邮箱，并且假设进程p1向邮箱发送消息，那么哪个进程将是接收者？可以通过强制只有两个进程可以共享一个邮箱或强制在给定时间只允许一个进程执行接收或随机选择任何进程并通知发送方来解决。邮箱可以对单个发送方/接收方设备私有，也可以在多个发送方/接收方之间共享。端口是这种邮箱的实现，可以有多个发送者和一个接收者。它用于客户端/服务端应用程序（这种情况下，服务器是接受者）。该端口由接收方进程拥有，并由操作系统根据接收进程的请求进行创建，并且可以在接收方终止自身进程时进行销毁。可以使用互斥的概念来强制只允许一个进程执行接收。**互斥邮箱**，有n个进程共享。发送方式非阻塞的发送消息。第一个接收进程进入临界区，所有其他进程将阻塞并等待。

现在，让我们使用消息传递概念来讨论生产者-消费者问题。生产者将物品（内部消息）放入邮箱，当邮箱中至少存在一条消息时，消费者可以消费物品。代码如下：

* 生产者代码

  ```c
  void Producer(void){ 
      int item;
      Message m;
  
      while(1){
          receive(Consumer, &m);
          item = produce();
          build_message(&m , item ) ;
          send(Consumer, &m);
      }
  }
  ```

* 消费者代码

  ```c
  void Consumer(void){
      int item;
      Message m;
  
      while(1){
          receive(Producer, &m);
          item = extracted_item();
          send(Producer, &m);
          consume_item(item);
      }
  }
  ```

## 进程的缺点

进程有利于资源的管理和保护，然而进程有着以下问题：

* 进程切换的代价、开销比较大
* 一个进程中也需要执行多个程序，实现不同功能
* 进程有时候性能比较低

因此线程的概念应运而生。